# Higher Order Entities
type User @entity(immutable: false) {
  id: Bytes! # Wallet address
  lpTokenBalance: BigDecimal! # Amount of LP tokens held
  shareOfPool: BigDecimal! # % of LP tokens held
  # totalUSUALRewards: BigInt! # Lifetime $USUAL rewards
  # totalFeesEarned: BigInt! # Any proportional fee share
  lastActivity: BigInt! # Timestamp of last deposit/withdraw
  pool: Pool! # Current pool
  txCount: BigInt! # Total txns interacting with protocol
  positionSnapshots: [PositionSnapshot!]! @derivedFrom(field: "user")
}

type PositionSnapshot @entity(immutable: true) {
  id: Bytes! # `${user}-${blockNumber}-${logIndex}`
  user: User! # User reference
  pool: Pool! # Curve Pool reference
  # rewardsAccumulated: BigInt! # Total $USUAL accrued
  # feesEarned: BigInt! # Trading fees earned via Curve
  timestamp: BigInt! # Timestamp of position creation
  lpTokenBalance: BigDecimal! # Amount of LP tokens held
  shareOfPool: BigDecimal! # % of LP tokens held
}

type Pool @entity(immutable: false) {
  id: Bytes! # Curve Pool address
  createdAt: BigInt!
  updatedAt: BigInt!
  name: String! # e.g., "USD0-USD0++"
  usd0Balance: BigInt! # USD0 in pool
  usd0PlusBalance: BigInt! # USD0++ in pool
  totalSupply: BigDecimal! # Total LP tokens in pool
  volume: BigInt! # total lifetime swap volume

  # Total lifetime liquidity movement
  usd0LiquidityAdded: BigDecimal!
  usd0LiquidityRemoved: BigDecimal!
  usd0PlusLiquidityAdded: BigDecimal!
  usd0PlusLiquidityRemoved: BigDecimal!

  users: [User!]! @derivedFrom(field: "pool") # All users providing liquidity
}

# perhaps pool should have a list of these transactions?
# to track the change in usd0 / usd0Plus over time?
type PoolTransaction @entity(immutable: true) {
  id: Bytes! # `${txHash}-${logIndex}`
  timestamp: BigInt!
  user: User!
  pool: Pool!
  type: String! # Deposit | Withdraw | Swap
  isSellingUsd0: Boolean # Whether the user is selling USD0 | if null it is a deposit/withdraw
  amountUSD0: BigInt
  amountUSD0Plus: BigInt
  gasUsed: BigInt
}

# Event Entities

type Transfer @entity(immutable: true) {
  id: Bytes!
  sender: Bytes! # address
  receiver: Bytes! # address
  value: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TokenExchange @entity(immutable: true) {
  id: Bytes!
  buyer: Bytes! # address
  sold_id: BigInt! # int128
  tokens_sold: BigInt! # uint256
  bought_id: BigInt! # int128
  tokens_bought: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TokenExchangeUnderlying @entity(immutable: true) {
  id: Bytes!
  buyer: Bytes! # address
  sold_id: BigInt! # int128
  tokens_sold: BigInt! # uint256
  bought_id: BigInt! # int128
  tokens_bought: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type AddLiquidity @entity(immutable: true) {
  id: Bytes!
  provider: Bytes! # address
  token_amounts: [BigInt!]! # uint256[usd0, usd0Plus]
  fees: [BigInt!]! # uint256[]
  invariant: BigInt! # uint256
  token_supply: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type RemoveLiquidity @entity(immutable: true) {
  id: Bytes!
  provider: Bytes! # address
  token_amounts: [BigInt!]! # uint256[usd0, usd0Plus]
  fees: [BigInt!]! # uint256[]
  token_supply: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type RemoveLiquidityOne @entity(immutable: true) {
  id: Bytes!
  provider: Bytes! # address
  token_id: BigInt! # int128 - 0 for usd0, 1 for usd0Plus
  token_amount: BigInt! # uint256
  coin_amount: BigInt! # uint256
  token_supply: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type RemoveLiquidityImbalance @entity(immutable: true) {
  id: Bytes!
  provider: Bytes! # address
  token_amounts: [BigInt!]! # uint256[usd0, usd0Plus]
  fees: [BigInt!]! # uint256[]
  invariant: BigInt! # uint256
  token_supply: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
